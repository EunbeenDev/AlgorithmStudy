# 5. 백트래킹(Backtracking)
- 해를 찾는 도중 해가 절대 될 수 없다고 판단되면, 되돌아가서 해를 다시 찾아가는 기법을 말한다. (되추적)
- 해결책에 대한 후보를 구축해 나아가다 가능성이 없다고 판단되는 즉시 후보를 포기(Backtrack)해 정답을 찾아가는 알고리즘
- DFS를 이용하여 해결
- 상태 공간 트리를 탐색하면서 각 루트에서 목표 상태에 도달할 때까지 깊이 우선 탐색을 수행
- 백트래킹은 최적화 문제와 결정 문제를 해결하는 데 사용

## 백트래킹과 DFS
- 백트래킹은 DFS를 이용하여 해를 찾는 도중 해가 될 것 같지 않다고 판단되면, 그 경로를 더 이상 가지 않고 되돌아가서 다시 해를 찾아가는 방법
- DFS는 모든 경로를 탐색하는 알고리즘 중 하나이며, 백트래킹은 DFS를 이용하여 불필요한 경로를 조기에 차단하여 시간을 절약하는 방법
- 백트래킹은 DFS의 일종이며, DFS는 백트래킹을 포함하는 개념

## 백트래킹의 구현
1. 상태 공간 트리의 깊이 우선 탐색을 이용
2. 각 루트에서 목표 상태에 도달할 때까지 깊이 우선 탐색을 수행
3. 불필요한 경로를 조기에 차단
4. 해가 될 가능성이 없다고 판단되면, 가지를 쳐내고 다른 루트로 바꿈
5. 해를 찾으면 탐색을 중지하고 해를 출력
6. 모든 해를 찾을 때까지 계속 탐색

### 코드
- N개의 원소를 가지는 배열에서 N개의 원소를 가지는 순열을 구하는 코드

```java
public class Backtracking {
    static int N = 4; // 순열의 크기
    static int[] arr = new int[N]; // 순열을 저장할 배열
    static boolean[] visited = new boolean[N]; // 방문 여부를 저장할 배열

    public static void main(String[] args) {
        backtracking(0);  // 백트래킹 시작
    }

    public static void backtracking(int depth) { // 백트래킹 함수 구현 (깊이를 파라미터로 받음)
        if (depth == N) {   // 탈출 조건
            for (int i = 0; i < N; i++) {
                System.out.print(arr[i] + " ");
            }
            System.out.println();   
            return;
        }

        for (int i = 0; i < N; i++) { // 모든 노드를 방문
            if (!visited[i]) { // 방문하지 않은 노드
                visited[i] = true; // 방문 처리
                arr[depth] = i + 1; // 해당 노드를 방문한 노드로 처리
                backtracking(depth + 1); // 다음 노드 방문
                visited[i] = false; // 방문 처리 해제
            }
        }
    }
}
```

